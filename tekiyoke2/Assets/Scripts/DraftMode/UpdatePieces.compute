// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Update
#define PIECES_BLOCK_SIZE 64

float randSimple(float2 v)
{
    return frac(sin(dot(v.xy, float2(12.9898, 78.233))) * 43758.5453);
}

struct Wind
{
    int currentIndex;
    float angle;
    float velocity;
    float timeOffset;
};

struct Node
{
    float  time;
    float2 pos;
    float4 col;
};

struct Input
{
    float2 pos;
};

RWStructuredBuffer<Wind>  _Winds;
RWStructuredBuffer<Node>  _Nodes;
RWStructuredBuffer<Input> _Inputs;

int _NumNodesPerWind;

float _DeltaTime;
float _Time;

uint NodeIndex(uint id)
{
    uint currentNode = _Winds[id].currentIndex;
    return id * _NumNodesPerWind + currentNode;
}

void GenerateInput(uint id)
{
    Input input;
    Node node = _Nodes[NodeIndex(id)];
    input.pos = node.pos + float2(cos(_Winds[id].angle), sin(_Winds[id].angle)) * _Winds[id].velocity * _DeltaTime;

    _Inputs[id] = input;
}

void UpdateWind(uint id)
{
    int oldIndex =  _Winds[id].currentIndex;
    int newIndex = (_Winds[id].currentIndex + 1) % _NumNodesPerWind;
    Wind wind = _Winds[id];
    wind.currentIndex = newIndex;
    if((_Time + wind.timeOffset) % 4 < 3)
    {
        wind.angle += -sin((_Time + wind.timeOffset) * 6.28) * _DeltaTime;
    }
    else
    {
        wind.angle -= 6.28 * _DeltaTime;
    }
    _Winds[id] = wind;

    Node newNode;
    newNode.pos  = _Inputs[id].pos;
    if(newNode.pos.x > 550)  newNode.pos.x -= 1100;
    if(newNode.pos.x < -550) newNode.pos.x += 1100;
    if(newNode.pos.y > 380)  newNode.pos.y -= 760;
    if(newNode.pos.y < -380) newNode.pos.y += 760;
    newNode.time = _Time;
    newNode.col = _Nodes[oldIndex + _NumNodesPerWind * id].col;

    _Nodes[NodeIndex(id)] = newNode;
}

[numthreads(PIECES_BLOCK_SIZE,1,1)]
void Update (uint3 id : SV_DispatchThreadID)
{
    GenerateInput(id.x);
    UpdateWind(id.x);
}

