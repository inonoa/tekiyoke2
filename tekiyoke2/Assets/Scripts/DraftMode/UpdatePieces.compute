// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Update
#define PIECES_BLOCK_SIZE 64
#define TAU 6.2831
#define PI 3.1416

float randSimple(float2 v)
{
    return frac(sin(dot(v.xy, float2(12.9898, 78.233))) * 43758.5453);
}

struct Wind
{
    int   currentIndex;
    float angle;
    float velocity;
    int   state;
    float timeOffset;
};

#define STATE_ROT 0
#define STATE_STR 1

struct Node
{
    float  time;
    float2 pos;
    float4 col;
};

RWStructuredBuffer<Wind>  _Winds;
RWStructuredBuffer<Node>  _Nodes;

int _NumNodesPerWind;
float2 _Area;
float2 _CameraPos;

float _DeltaTime;
float _Time;
float4 _HeroInfo;

uint NodeIndex(uint id)
{
    uint currentNode = _Winds[id].currentIndex;
    return id * _NumNodesPerWind + currentNode;
}

bool NearHero(float2 pos)
{
    return distance(_HeroInfo.xy, pos) < 100;
}

float2 posInCamera(float2 pos)
{
    float2 ans = pos;
    if(ans.x > _CameraPos.x + _Area.x / 2) ans.x -= _Area.x;
    if(ans.x < _CameraPos.x - _Area.x / 2) ans.x += _Area.x;
    if(ans.y > _CameraPos.y + _Area.y / 2) ans.y -= _Area.y;
    if(ans.y < _CameraPos.y - _Area.y / 2) ans.y += _Area.y;
    return ans;
}

float2 Polar2Cartesian(float r, float theta)
{
    return float2(cos(theta), sin(theta)) * r;
}

void UpdateWind(uint id)
{
    int oldIndex =  _Winds[id].currentIndex;
    int newIndex = (_Winds[id].currentIndex + 1) % _NumNodesPerWind;
    
    float2 nextPos = _Nodes[NodeIndex(id)].pos + Polar2Cartesian(_Winds[id].velocity * _DeltaTime, _Winds[id].angle);

    Wind wind = _Winds[id];
    wind.currentIndex = newIndex;

    //基本的な移動
    if(wind.state == STATE_STR)
    {
        wind.angle += -sin(_Time * TAU) * _DeltaTime;

        wind.timeOffset -= _DeltaTime;
        if(wind.timeOffset <= 0)
        {
            wind.state = STATE_ROT;
            wind.timeOffset += 1;
        }
    }
    else if(wind.state == STATE_ROT)
    {
        wind.angle -= TAU * _DeltaTime;

        wind.timeOffset -= _DeltaTime;
        if(wind.timeOffset <= 0)
        {
            wind.state = STATE_STR;
            wind.timeOffset += 3;
        }
    }
    wind.angle %= TAU;

    //主人公を避ける
    if(NearHero(nextPos))
    {
        float2 fromHero = nextPos - _HeroInfo.xy;
        float angleFromHero = (atan2(fromHero.y, fromHero.x) + TAU) % TAU;
        float distAngle = (angleFromHero - wind.angle + TAU) % TAU;

        bool red_ = (distAngle > (PI))     && (distAngle < 1.5 * PI);
        wind.angle = red_ ? wind.angle - _DeltaTime * 5 : wind.angle;
        
        bool add_ = (distAngle > (PI / 2)) && (distAngle < PI);
        wind.angle = add_ ? wind.angle + _DeltaTime * 5 : wind.angle;
    }

    _Winds[id] = wind;

    Node newNode;
    newNode.pos  = posInCamera(nextPos);
    newNode.time = _Time;
    newNode.col  = _Nodes[oldIndex + _NumNodesPerWind * id].col;

    _Nodes[NodeIndex(id)] = newNode;
}

[numthreads(PIECES_BLOCK_SIZE,1,1)]
void Update (uint3 id : SV_DispatchThreadID)
{
    UpdateWind(id.x);
}

